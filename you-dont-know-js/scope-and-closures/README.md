# Scope & Closures

这里主要记录的书中在Scope & Closures这一章中用到的例子，以及自己对该方面知识的理解。

### Concepts

- Engine (引擎)

负责从头到尾编译和执行Javascript。

- Compiler (编译器)

引擎的好朋友之一，负责语法分析(parsing)及代码生成等脏活累活。

- Scope (作用域)

引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查找，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### Nested Scope & Scope Chain

被引用（不是定义）的变量首先会在自己所处的作用域中搜索。如果没有找到，就会向它的外部引用（外部环境的引用），如果仍没找到，那么就会向它的外部引用的外部引用去搜索，直到搜索至全局作用域。如果全局作用域中没找到，那么该变量就是未定义的（undefined），JS引擎会抛出ReferenceError异常。

### Lexical Scope
无论函数在哪里被调用， 也无论它如何被调用， 它的词法作用域(lexical scope)都只由函数被声明(定义)时所处
的位置决定。

eval(..) 可以在运行期修改书写期的词法作用域。

在程序中动态生成代码的使用场景非常罕见， 因为它所带来的好处无法抵消性能上的损
失。

with 可以在运行期创建新的词法作用域。

with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。在严格模式下，with 被完全禁止， 而在保留核心功能的前提下， 间接或非安全地使用
eval(..) 也被禁止了。

__欺骗词法作用域会导致性能下降。__

### Function vs. Block Scope
可以把变量和函数包裹在一个函数的作用域中， 然后用这个作用域
来“ 隐藏” 它们。 

在任意代码片段外部添加包装函数， 可以将内部的变量和函数定义“ 隐
藏” 起来， 外部作用域无法访问包装函数内部的任何内容。

函数表达式可以是匿名的，
而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

始终给函数表达式命名是一个最佳实践。